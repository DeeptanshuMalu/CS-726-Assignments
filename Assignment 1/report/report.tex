\documentclass[12pt]{article}

\usepackage{geometry}
\geometry{a4paper, margin=1in}

\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{hyperref}

\title{CS 726: Programming Assignment 1}
\author{Deeptanshu Malu \quad Deevyanshu Malu \quad Neel Rambhia}
\date{}

\begin{document}

\maketitle

\section{Preprocessing}

The preprocessing step involves converting the given data into a suitable format for further processing. We have done the following preprocessing steps:

\begin{enumerate}
    \item \textbf{Clique Potentials:} Converted all the cliques and potentials data into a dictionary format. The keys of the dictionary are the cliques and the values are the potentials. \item \textbf{Edges:} Converted all the cliques into a set of tuples, where each tuple consists of two nodes that are connected by an edge.
    \item \textbf{Nodes:} Converted the edge set into a set of all the nodes in the graph.
\end{enumerate}

\section{Triangulation}

\subsection{triangulate\_and\_get\_cliques}
Here are some of the functions we have defined for the triangulation and maximum clique finding process:

\begin{enumerate}
    \item \textbf{is\_simplicial:} This function checks if a given node is simplicial in the graph. A node is simplicial if the neighbors of the node form a clique.

    \item \textbf{find\_simplicial\_vertex:} This function finds a simplicial vertex in the graph. If no simplicial vertex is found, it returns None.

    \item \textbf{make\_vertex\_simplicial:} This function makes a given node simplicial by adding edges between all the neighbors of the node.

    \item \textbf{chordal\_graph\_with\_heuristic:} In this function we do the following:
        \begin{enumerate}
            \item Find a simplicial vertex in the graph.
            \item If a simplicial vertex is found, take its neighbors and store it in the maximum clique list.
            \item If no simplicial vertex is found, take a node based on the heuristic that the node has the minimum degree. Make this node simplicial and take its neighbors and store it in the maximum clique list.
            \item Repeat the process until all the nodes are covered.
            \item If a clique found is already a subset of a previously found clique, discard it.
            \item Return the maximal cliques found.
        \end{enumerate}

\end{enumerate}

\section{Junction Tree Construction}

\subsection{get\_junction\_tree}
In this section, we have defined the following functions for constructing the junction tree:

\begin{enumerate}
    \item \textbf{create\_junction\_graph}: This function creates a junction graph from the found maximal cliques. We iterate over all the maximal cliques and add an edge between two maximal cliques if they have a common node. We also assign a weight to each edge which is the size of the intersection of the two maximal cliques.
    
    \item \textbf{make\_junction\_tree}: This function creates a junction tree from the junction graph. We first find the maximum spanning tree of the junction graph using Kruskal's algorithm. This tree is the junction tree.
\end{enumerate}

\subsection{assign\_potentials\_to\_cliques}

In this section, we have defined the following functions for assigning potentials to the cliques:

\begin{enumerate}
    \item \textbf{multiply\_potentials}: This function takes two potentials and there corresponding cliques and multiplies them to get a new potential and a new clique.
\end{enumerate}

After this we iterate over all the maximal cliques and for each clique, we find all the clique potentials that are subsets of the maximal clique. We multiply all these potentials to get the potential for the maximal clique.

\section{Marginal Probability}

\subsection{get\_z\_value}
In this section, we have defined the following functions for finding the Z value:

\begin{enumerate}
    \item \textbf{create\_empty\_message\_dict}: This function creates an empty message dictionary for all the cliques in the junction tree. The dictionary has the sender clique as the key and the value is a dictionary with the receiver clique as the key and its value is the message from the sender clique to the receiver clique.
    
    \item \textbf{multiply\_messages}: This function takes a potential of the clique or a precomputed value (potential is already multiplied with some messages) and a message to be multiplied as input and it multiplies them to get a new potential.
    
    \item \textbf{condense\_message}: This function takes a potential and the nodes to be marginalized on and marginalizes the potential to get a new potential.
    
    \item \textbf{send\_message}: In this function, we do a forward pass of message passing. These are the steps we follow:
        \begin{enumerate}
            \item We maintain a list of nodes who have to send messages to their neighbors. This is initialized with the leaf nodes of the junction tree.
            \item We iterate over all the nodes in the list and send messages from the node to all its neighbors using the $\texttt{multiply\_messages}$ and $\texttt{condense\_message}$ functions.
            \item When a message is sent from a node to its neighbor, we update the message dictionary.
            \item After iterating over all the nodes in the list, we remove the nodes from the list and add their neighbors to whom messages were sent to the list.
            \item We repeat the process until the list is empty and final non-empty value of the list is the root of the junction tree.
        \end{enumerate}
    
    \item \textbf{receive\_message}: In this function, we do a backward pass of message passing. These are the steps we follow:
        \begin{enumerate}
            \item We maintain a list of nodes who have to send messages to their neighbors. This is initialized with the root of the junction tree.
            \item We iterate over all the nodes in the list and send messages from the node to all its neighbors using the $\texttt{multiply\_messages}$ and $\texttt{condense\_message}$ functions.
            \item When a message is sent from a node to its neighbor, we update the message dictionary.
            \item After iterating over all the nodes in the list, we remove the nodes from the list and add their neighbors to whom messages were sent to the list.
            \item We repeat the process until the list is empty.
        \end{enumerate}
    
    \item \textbf{calc\_z}: This function calculates the Z value using the fully updated message dictionary. We simply choose any maximal clique and marginalize it on all it component nodes to get the Z value.
    
\end{enumerate}




\section{MAP Assignment}
\section{Top k Assignments}

\end{document}